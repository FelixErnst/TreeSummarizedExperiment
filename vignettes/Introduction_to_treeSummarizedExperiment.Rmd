---
title: "Introduction to TreeSummarizedExperiment"
author: 
- name: Ruizhu HUANG
  affiliation: 
  - Institute of Molecular Life Sciences, University of Zurich.
  - SIB Swiss Institute of Bioinformatics.
- name: Charlotte Soneson
  affiliation: 
  - Institute of Molecular Life Sciences, University of Zurich.
  - SIB Swiss Institute of Bioinformatics.
- name: Mark Robinson
  affiliation: 
  - Institute of Molecular Life Sciences, University of Zurich.
  - SIB Swiss Institute of Bioinformatics.
package: TreeSummarizedExperiment
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Tree Aggregation}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: TreeSE_vignette.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```


# Introduction 

The `TreeSummarizedExperiment` class is an extensions of the
`SingleCellExperiment` class. It's used to store rectangular data of
experimental results as in a `SingleCellExperiment`, and also support the
storage of a hierarchical structure and its link information to the rectangular
data. 

# TreeSummarizedExperiment {#tse-class}

## Anatomy of TreeSummarizedExperiment

```{r strTSE, echo=FALSE, fig.cap= "The structure of the TreeSummarizedExperiment class."}
knitr::include_graphics("tse.png")
```
Compared with the `SingleCellExperiment` class, `TreeSummarizedExperiment` has
four more slots.

* `rowTree`: the hierarchical structure on the rows of the `assays` tables.
* `rowLinks`: the link between rows of the `assays` tables and the `rowTree`.
* `colTree`: the hierarchical structure on the columns of the `assays` tables.
* `colLinks`: the link information between columns of `assays` tables and the
`colTree`.

The `rowTree` and `colTree` could be empty (`NULL`) if no trees are available.
Correspondingly, the `rowLinks` and `colLinks` would have $0$ rows. Other slots
in `TreeSummarizedExperiment` are exactly the same as those in
`SingleCellExperiment`.


## Toy data

```{r}
suppressPackageStartupMessages({
    library(TreeSummarizedExperiment)
    library(S4Vectors)
    library(ggtree)
    library(ape)})
```

We generate a **toyTable** with observations of 5 entities collected from 4
samples.
```{r}
# assays data
toyTable <- rbind(rep(0, 4), matrix(1:16, nrow = 4))
colnames(toyTable) <- paste(rep(LETTERS[1:2], each = 2), 
                            rep(1:2, 2), sep = "_")
rownames(toyTable) <- paste("entity", seq_len(5), sep = "")
toyTable
```

The descriptions of the `r nrow(toyTable)` entities and `r ncol(toyTable)`
samples are given in the **rowInf** and **colInf**, respectively.
```{r}
# row data
rowInf <- DataFrame(var1 = sample(letters[1:2], 5, replace = TRUE),
                    var2 = sample(c(TRUE, FALSE), 5, replace = TRUE),
                    row.names = rownames(toyTable))
rowInf
# column data
colInf <- DataFrame(gg = c(1, 2, 3, 3),
                    group = rep(LETTERS[1:2], each = 2), 
                    row.names = colnames(toyTable))
colInf
```

The hierarchical structure of the `r nrow(toyTable)` entities is denoted as
**treeR**. The hierarchical structure of the `r ncol(toyTable)` samples is
denoted as **treeC**. We create them by using the function `rtree` from the
package `r CRANpkg("ape")`.
```{r}
# Toy tree 1
data("treeR")
# Toy tree 2
data("treeC")
```

The created trees are `phylo` objects. The `phylo` object is actually a list
with at least four elements: `edge`, `tip.label`, `edge.length`, and `Nnode`.
```{r}
class(treeR)
str(treeR)
```

The package `r Biocpkg("ggtree")` has been used to visualize the tree. The node
labels and node numbers are in blue and orange texts, respectively. The
**treeR** has no labels for internal nodes.

```{r rtree, fig.cap="\\label{rtree} The structure of the row tree"}
# Visualize the row tree
ggtree(treeR, size = 2) +
geom_text2(aes(label = node), color = "darkblue",
                hjust = -0.5, vjust = 0.7, size = 6) +
geom_text2(aes(label = label), color = "darkorange",
            hjust = -0.1, vjust = -0.7, size = 6)
```

```{r ctree, fig.cap="\\label{ctree} The structure of the column tree"}
# Visualize the column tree
ggtree(treeC, size = 2) +
geom_text2(aes(label = node), color = "darkblue",
                hjust = -0.5, vjust = 0.7, size = 6) +
geom_text2(aes(label = label), color = "darkorange",
            hjust = -0.1, vjust = -0.7, size = 6)
```

## The construction of `TreeSummarizedExperiment`

The `TreeSummarizedExperiment` class is used to store the toy data:
**toyTable**, **rowInf**, **colInf**, **treeC** and **treeR**, To correctly
store data, the link information between the rows (or columns) of **toyTable**
and the nodes of the **treeR** (or **treeC**) is requried to provide via a
column `nodeLab` in the `rowData` (or `colData`). Those columns or rows that
don't match with the tree structure are removed. The link data between the
`assays` tables and the tree data is automatically generated in the
construction.

Below shows an example to construct `TreeSummarizedExperiment` without the
column tree.
```{r}
# add a column (nodeLab) to the row data 
rowInf$nodeLab <- c(treeR$tip.label)
rse <- TreeSummarizedExperiment(assays = list(toyTable),
                                rowData = rowInf,
                                colData = colInf,
                                rowTree = treeR)
```

When printing out **rse**, we see a similar message as `SingleCellExperiment` with four additional lines about `rowLinks`, `rowTree`, `colLinks` and `colTree`. Here, **rse** stores a row tree (`phylo` object), and the `rowLinks` has `r nrow(rse)` rows that is exactly the same as the number of rows in the `assays` tables. More details about the link data could be found in Section \@ref(linkData).

```{r}
rse
```

If the row tree and the column tree are both available, the
`TreeSummarizedExperiment` could be constructed similarly as below. Here, the
column names of the `assays` table match with the node labels used in the column
tree. So, we could omit the step of adding the column `nodeLab` to the column
data.
```{r}
## omit this step
# add a column (nodeLab) to the column data;
# colInf$nodeLab <- treeC$tip.label
all(colnames(toyTable) %in% c(treeC$tip.label, treeC$node.label))

tse <- TreeSummarizedExperiment(assays = list(toyTable),
                                rowData = rowInf,
                                colData = colInf,
                                rowTree = treeR,
                                colTree = treeC)
```

Compared to **rse**, **tse** includes also a column tree. The column link data
(`colLinks`) with `r ncol(tse)` rows is automatically generated. The number of
rows in the link data is decided by the column dimension of the `assays` tables.
```{r}
tse
```


## The accessor functions
### Assays, rowData, colData, and metadata

It's exactly the same work as shown in `r Biocpkg("SingleCellExperiment")` to exctract slots inherited from the `SingleCellExperiment` class.

```{r}
# to get the first table in the assays
(count <- assays(tse)[[1]])
```

```{r}
# to get row data
(rowD <- rowData(tse))
```

```{r}
# to get column data
(colD <- colData(tse))
```

```{r}
# to get metadata: it's empty here
(mdata <- metadata(tse))
```

### rowLinks, colLinks {#linkData}

The row link and column link could be accessed via `rowLinks` and `colLinks`,
respectively. The output would be a `LinkDataFrame` object. The `LinkDataFrame`
class is extended from the `DataFrame` class with the restriction that it has at
least four columns: **nodeLab**, **nodeLab\_alias**, **nodeNum**, and
**isLeaf**. More details about the `DataFrame` class could be found in the `r
Biocpkg("S4Vectors")` package.

* nodeLab: the labels of nodes on the tree
* nodeLab\_alias: the alias labels of nodes on the tree
* nodeNum: the numbers of nodes on the tree
* isLeaf: it's to indicate whether the node is a leaf node

When a `phylo` tree is available in the `rowTree`, we could see a
`LinkDataFrame` object in the `rowLinks`. The number of rows of `rowLinks` data
matches with the number of rows of `assays` tables.


```{r}
(rLink <- rowLinks(tse))
```

```{r}
class(rLink)
showClass("LinkDataFrame")
```

```{r}
nrow(rLink) == nrow(tse)
```

Similarly, the number of rows of `colLinks` data matches with the number of columns of `assays` table.
```{r}
(cLink <- colLinks(tse))
nrow(cLink) == ncol(tse)
```

If the tree is not available, the corresponding link data would have zero rows.
```{r}
colTree(rse)
colLinks(rse)
```

The link data is automatically generated when constructing the
`TreeSummarizedExperiment` object. We highly recommend users not to modify it
manually; otherwise the link might be broken. For R packages developers, we show
in the Section \@ref(modifyLink) about how to update the link.


## The subseting function

We could use `[` to subset the `TreeSummarizedExperiment`. To keep tracking from
the original data, the `rowTree` and `colTree` stay the same in the subsetting.
```{r}
tse1 <- tse[1:2, 1]
tse1
```

The annotation data on the row and column dimension is changed accordingly.
```{r}
# The first four columns are from rowLinks data and the others from rowData
cbind(rowLinks(tse1), rowData(tse1))
```

```{r}
# The first four columns are from rowLinks data and the others from rowData
cbind(colLinks(tse1), colData(tse1))
```


# Aggregation

The aggregation is allowed on the row and the column dimension. 

## The column dimension {#aggCol}

Here, we show the aggregation on the column dimension. The
`TreeSummarizedExperiment` object is assigned to the argument `x`. The desired
aggregation level is given in `colLevel`. The level could be specified via the
node label (the orange texts in Figure \@ref(fig:ctree)) or the node number (the
blue texts in Figure \@ref(fig:ctree)). We could further decide how to aggregate
via the argument `FUN`.

```{r}
# use node labels to specify colLevel
aggCol <- aggValue(x = tse, 
                   colLevel = c("GroupA", "GroupB"),
                   FUN = sum)
# or use node numbers to specify colLevel
aggCol <- aggValue(x = tse, colLevel = c(6, 7), FUN = sum)
```


```{r}
assays(aggCol)[[1]]
```

The `rowData` doesn't change, but the `colData` adjusts with the change of the
\code{assays} table. For example, the column **group** has the `A` value for
`GroupA` because the descendant nodes of `GroupA` all have the value `A`; the
column **gg** has the `NA` value for `GroupA` because the descendant nodes of
`GroupA` have different values, (1 and 2).
```{r}
# before aggregation
colData(tse)
# after aggregation
colData(aggCol)
```

The `colLinks` is updated to link the new rows of `assays` tables and the column
tree.
```{r}
# the link data is updated
colLinks(aggCol)
```
From the Figure \@ref(fig:rtree), we could see that the nodes 6 and 7 are
labelled with `GroupA` and `GroupB`, respectively. This agrees with the
`LinkData` of the column data.

## The row dimension {#aggRow}

It's similar to the aggregation on the row dimension, except that the level
should be specified via `rowLevel`.

```{r}
aggRow <- aggValue(x = tse, rowLevel = 7:9, FUN = sum)
```

Now, the output `assays` table has 3 rows.

```{r}
assays(aggRow)[[1]]
```

We could see which row corresponds to which nodes via the `rowLinks` data.
```{r}
rowLinks(aggRow)
```
The Figure \@ref(fig:rtree) shows that the nodes 7, 8 and 9  have no labels.
Therefore, the `nodeLab` column in `LinkData` of the row data has missing value.
They are all internal nodes and hence the column `isLeaf` has only `FALSE`
value.

## Both dimensions

The aggregation on both row and column dimensions could be performed in one step
using the same function specified via `FUN`. If different functions are required
for different dimension, it's suggested to do it in two steps as described in
Section \@ref(aggRow) and Section \@ref(aggCol) because the order of aggregation
might matter.

```{r}
aggBoth <- aggValue(x = tse, colLevel = c(6, 7), 
                    rowLevel = 7:9, FUN = sum)
```

As expected, we obtain a table with 3 rows (`rowLevel = 7:9`) and 2 columns
(`colLevel = c(6, 7)`). 
```{r}
assays(aggBoth)[[1]]
```


# Aggregation on the taxonomic table

In some case, the information of the hierarchical structure is available as a
`data.frame` instead of the `phylo` object mentioned above. To do the work
listed above, we could convert the `data.frame` to the `phylo` class.

The function `toTree` outputs the hierarchical information into a `phylo`
object. If the data set is large, we suggest to allow `cache = TRUE` to speed up
the aggregation step.

```{r}
# The toy taxonomic table
taxTab <- data.frame(Kindom = rep("A", 5),
                     Phylum = c("B1", rep("B2", 4)),
                     Class = c("C1", "C2", "C3", "C3", NA),
                     OTU = c("D1", "D2", "D3", "D4", NA))
# convert to a phylo tree
taxTree <- toTree(data = taxTab, cache = FALSE)
ggtree(taxTree)+
geom_text2(aes(label = node), color = "darkblue",
                hjust = -0.5, vjust = 0.7, size = 6) +
geom_text2(aes(label = label), color = "darkorange",
            hjust = -0.1, vjust = -0.7, size = 6) +
    geom_point2()
```


```{r}
# construct a TreeSummarizedExperiment object
rowInf$nodeLab <- taxTree$tip.label
taxTSE <- TreeSummarizedExperiment(assays = list(toyTable),
                                   rowData = rowInf,
                                   rowTree = taxTree)
```

Here is about how to aggregate to the phylum level.
```{r}
# specify the level
taxLab <- c(taxTree$tip.label, taxTree$node.label)
ii <- startsWith(taxLab, "Phylum:") 
(l1 <- taxLab[ii])
# aggregate
aggTAX <- aggValue(x = taxTSE, rowLevel = l1, FUN = sum)
```


```{r}
assays(aggTAX)[[1]]
```

```{r}
rowData(aggTAX)
```


The aggregation could be on any freely combined level.
```{r}
# specify the level
l2 <- c("Class:C3", "Phylum:B1")
# aggregate
aggF <- aggValue(x = taxTSE, rowLevel = l2, FUN = sum)
```


```{r}
assays(aggF)[[1]]
```

```{r}
rowData(aggF)
```



# Additional

## More about functions working on the `phylo` object.

Here, we show some functions as examples to manipulate or to extract information
from the `phylo` object. More functions could be found in other packages, such
as `r CRANpkg("ape")`, `r CRANpkg("tidytree")`. These functions might be useful
when R package developers want to create their own functions to work on the
`TreeSummarizedExperiment` class.

Below shows the node label (black texts) and node number (blue texts) of each
node on an example tree.
```{r}
ggtree(tinyTree, branch.length = "none") +
    geom_text2(aes(label = label), hjust = -0.3) +
    geom_text2(aes(label = node), vjust = -0.8,
               hjust = -0.3, color = 'blue') 
```

### print out nodes of the tree

We could specify to print out all nodes (`type = "all"`), the leaves (`type =
"leaf"`) or the internal nodes (`type = "internal"`).

```{r}
printNode(tree = tinyTree, type = "all")
```

### Count the number of nodes

```{r}
# The number of leaves
countLeaf(tree = tinyTree)

# The number of nodes (leaf nodes and internal nodes)
countNode(tree = tinyTree)
```

### Translation between the node label and the node number

The translation between the labels and the numbers of nodes could be achieved by
the function `transNode`. 
```{r}
transNode(tree = tinyTree, node = c(12, 1, 4))
```

```{r}
transNode(tree = tinyTree, node = c("t4", "Node_18"))
```

### find the descendants 

To get descendants that are on the leaf level, we could set the argument
`only.leaf = TRUE`.
```{r}
# only the leaf nodes
findOS(tree = tinyTree, node = 17, only.leaf = TRUE)
```

The argument `only.leaf = TRUE` is set to get all descendants 
```{r}
# all descendant nodes
findOS(tree = tinyTree, node = 17, only.leaf = FALSE)
```

### find the sibling node

The input `node` could be either the node label or the node number. 
```{r}
findSibling(tree = tinyTree, node = 5)
findSibling(tree = tinyTree, node = "t4")
```

### find the share node

This would find the first node that joined by the specified nodes in `node` in
the path to the root.
```{r}
shareNode(tree = tinyTree, node = c(5, 6))
```


### identify a leaf node
```{r}
isLeaf(tree = tinyTree, node = 5)
isLeaf(tree = tinyTree, node = 17)
```

### calculate the distance between two nodes

The distance between any two nodes on the tree could be calculated by
`distNode`.
```{r}
distNode(tree = tinyTree, node = c(1, 5))
```

### prune tree via leaves

We could specify the leaf nodes `rmLeaf` to remove parts of a tree. If
`mergeSingle = TRUE`, the internal node that is connected to the removed leaf
nodes is removed too; otherwise, it is kept.

```{r}
NT1 <- pruneTree(tree = tinyTree, rmLeaf = c(4, 5),
                mergeSingle = TRUE)
ggtree(NT1, branch.length = "none") +
    geom_text2(aes(label = label), color = "darkorange",
               hjust = -0.1, vjust = -0.7) +
    geom_point2()

NT2 <- pruneTree(tree = tinyTree, rmLeaf = c(4, 5),
                mergeSingle = FALSE)
ggtree(NT2, branch.length = "none") +
    geom_text2(aes(label = label), color = "darkorange",
               hjust = -0.1, vjust = -0.7) +
    geom_point2()
```

### convert a `phylo` object to a matrix

Each row gives a path that connects a leaf and the root.
```{r}
matTree(tree = tinyTree)
```

## Customize functions for the `TreeSummarizedExperiment` class

We show examples about how to create functions for the
`TreeSummarizedExperiment`. R package developers could customize their functions
based on the functions provided above on the `phylo` object or develop their own
ones.

Here, a function `rmRows` is created to remove entities (on rows) that have zero
in all samples (on columns) in the first `assays` table.

```{r}
# dat: a TreeSummarizedExperiment
rmRows <- function(dat) {
    # calculate the total counts of each row
    count <- assays(dat)[[1]]
    tot <- apply(count, 1, sum)
    
    # find the row with zero in all columns
    ind <- which(tot == 0)
    
    # remove those rows
    out <- dat[-ind, ]
    return(out)
    
}
(rte <- rmRows(dat = tse))
rowLinks(rte)
```

The function `rmRows` doesn't update the tree data. To update the tree, we could
do it as below.

```{r}
updateTSE <- function(dat) {
    # extract the linkData
    rowL <- rowLinks(dat)

    # check the nodeNum available
    nodeAv <- rowL$nodeNum

    # extract the tree data
    rowT <- rowTree(dat)

    # list all the leaves of the tree
    leaf <- printNode(tree = rowT, type = "leaf")$nodeNum
    

    # find leaves that are on the tree but not on the assay table
    out <- setdiff(leaf, nodeAv)

    # remove leaves that don't match with the assay table
    # pruneTree is a function work on the phylo class
    newTree <- pruneTree(tree = rowT, rmLeaf = out, mergeSingle = TRUE)

    # Not all trees have internal node labels, so nodeLab_alias is used to
    # update the link data
    rowNL <- rowL
    rowNL$nodeNum <- transNode(tree = newTree, node = rowL$nodeLab_alias,
                               use.alias = TRUE)
    rowNL$nodeLab <- transNode(tree = newTree, node = rowNL$nodeNum,
                               use.alias = FALSE)
    rowNL$isLeaf <- isLeaf(tree = newTree, node = rowNL$nodeNum)

    ## update the tree
    newDat <- BiocGenerics:::replaceSlots(dat,
                                          rowLinks = rowNL,
                                          rowTree = newTree)
    return(newDat)
}
```

Now the row tree has four leaves.
```{r}
ntse <- updateTSE(dat = rte)
ntse
rowLinks(ntse)
```

# Session Info

```{r}
sessionInfo()
```
